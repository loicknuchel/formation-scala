{
  "trackId" : "archisec",
  "talkType" : "Conference",
  "track" : "Architecture, Performance et Securité",
  "summaryAsHtml" : "<p>In a Microservices architecture with multiple moving parts we can’t allow that a single complement downtime breaks down the entire system. Dealing with stateless code is easy, but it gets much harder when we have to deal with persistent state. In this scenario, zero downtime migrations are paramount to guarantee integrity and consistency.</p>\n<p>Within all the Microservices characteristics, undoubtedly the one that creates more perplexity is the “one database per Microservice”. However, very few teams have the privilege of starting something from scratch: most of the times they have a legacy database that will survive any new implementation.</p>\n<p>In legacy systems you traditionally have a model that adopts transactions and CRUD. Now we must reassess some of these concepts. In this talk we’ll discuss consistency, CRUD and CQRS, Event Sourcing, and how these techniques relate to each other in many different integration strategies for databases. We’ll explore Views, Materialized Views, Mirror Tables, Event Sourcing, Data Virtualization, Change Data Capture, and how these strategies enable you to build up a Microservices architecture from a legacy monolithic relational database.</p>\n",
  "id" : "OWC-3820",
  "speakers" : [
    {
      "link" : {
        "href" : "http://cfp.devoxx.fr/api/conferences/DevoxxFR2017/speakers/8dda9845b6dcbf7e5321b1ede3d86139c21ac0e3",
        "rel" : "http://cfp.devoxx.fr/api/profile/speaker",
        "title" : "Edson Yanaga"
      },
      "name" : "Edson Yanaga"
    }
  ],
  "title" : "Migrating to Microservice Databases: From Relational Monolith to Distributed Data",
  "lang" : "en",
  "summary" : "In a Microservices architecture with multiple moving parts we can’t allow that a single complement downtime breaks down the entire system. Dealing with stateless code is easy, but it gets much harder when we have to deal with persistent state. In this scenario, zero downtime migrations are paramount to guarantee integrity and consistency.\r\n\r\nWithin all the Microservices characteristics, undoubtedly the one that creates more perplexity is the “one database per Microservice”. However, very few teams have the privilege of starting something from scratch: most of the times they have a legacy database that will survive any new implementation.\r\n\r\nIn legacy systems you traditionally have a model that adopts transactions and CRUD. Now we must reassess some of these concepts. In this talk we’ll discuss consistency, CRUD and CQRS, Event Sourcing, and how these techniques relate to each other in many different integration strategies for databases. We’ll explore Views, Materialized Views, Mirror Tables, Event Sourcing, Data Virtualization, Change Data Capture, and how these strategies enable you to build up a Microservices architecture from a legacy monolithic relational database."
}